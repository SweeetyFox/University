\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}

\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

\title{Homework 8}
\date{2019-05-05}
\author{Dimitrov Blagoi}

\begin{document}
  \pagenumbering{gobble}
  \maketitle
  \newpage
  \pagenumbering{arabic}

  \newpage

  \myparagraph{Задание 2}
  Используем алгоритм нахождения ближайшего общего предка. Мы разделим каждый
  запрос $(a_{i}, b_{i})$ на два вертикальных пути, чтобы было проще с ним работать.

  Для каждой вершины будем хранить число, изначально оно нуль. Для каждой вершины
  увеличиваем значение на колличество путей в которых она является концом, и уменьшаем на колличество
  в которых - началом. Таким образом получим, что для любого ребра сумма в его поддереве, т.е.
  в поддереве нижней вершины это колличество запросов, которые проходят через это ребро.

  Будем спускаться по дереву, каждый раз идя по "тяжелому" ребру, т.е. по тому, что
  содержит в наибольшем колличестве путей (по аналогии с Long Path Decomposition).

  Для всех остальных вершин, в которые можем попасть по другим ребрам - будет начат новый
  путь.

  Теперь докажем, что наше покрытие является статически оптимальным.
  Рассмотрим покрытие, отличное от нашего. Рассмотрим вершину, которая принадлежит не тому пути,
  что в нашем покрытии(хотя бы одна такая всегда есть). Так как в нашем покрытии путь продолжился по тяжелому ребру,
  то в новом ребре он продолжился по легкому. Нам интересны запросы, которые проходят через эти два ребра.
  По нашему ребру проходит больше, или, если быть точным, не меньше запросов, чем по новому, т.к. наше - тяжелое.
  Следовательно число переходов не уменьшится.

  Получаем, что покрытие оптимально.
  \begin{flushright}
    $\blacksquare$
  \end{flushright}

  \newpage

  \myparagraph{Задание 3}

  Как и в предыдущей задаче, разобьем все наши запросы на вертикальные пути. Разобьем множество всех вершин на несколько так,
  чтобы в одном множестве находились вершины, у которых были одинаковые x:

  $x = depth(vertex) mod (\log_2 n)$

  Очевидно что $\exists$ x: мощность его множества не больше  $\frac{n}{\log_2 n}$

  На этом множестве сделаем двоичный подъем с шагом в логарифм. Построить его можно за
   $ O(\log_2 n \cdot \frac{n}{\log_2 n}) $

  Пусть надо подняться из вершины v в вершину u. Наш путь разделится на три этапа:

  1) От v до нашего множества, на котором мы построили двоичный

  подъем.

  2) В этом множестве.

  3) От этого множества до u.

  Ассмиптоика:

  1) $O(\log_2 n)$. Просто поднимаемя по ребрам.

  2) $O(\log_2 n)$. Скачем двоичным подъемом.

  3) $O(\log_2 n)$. Опять просто поднимаемя по ребрам.

  Таблицу ассоциативной функции считаем аналогично двоичному подъему.

  \begin{flushright}
    $\blacksquare$
  \end{flushright}


 \end{document}
